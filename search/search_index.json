{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the bioinformatics training for Bacterial Genomics and \u00b6 You will find on the left menu several tutorials, from basics unix manipulations to more complex HTS data analyses. Thanks and contributors \u00b6 The tutorials are developed by Juliette Hayer and Lokman Galal (Institut de Recherche pour le D\u00e9veloppement) Some of them are inspired from the teaching materials of Hadrien Gourl\u00e9 ( https://github.com/HadrienG ). Thanks to him :-) We created some of them together during our time at the Swedish University of Agricultural Sciences (SLU). Thanks to SLU, to the SLU Global bioinformatics Centre (SGBC) and to SLUBI ( SLU Bioinformatics Infrastructure ) Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-the-bioinformatics-training-for-bacterial-genomics-and","text":"You will find on the left menu several tutorials, from basics unix manipulations to more complex HTS data analyses.","title":"Welcome to the bioinformatics training for Bacterial Genomics and"},{"location":"#thanks-and-contributors","text":"The tutorials are developed by Juliette Hayer and Lokman Galal (Institut de Recherche pour le D\u00e9veloppement) Some of them are inspired from the teaching materials of Hadrien Gourl\u00e9 ( https://github.com/HadrienG ). Thanks to him :-) We created some of them together during our time at the Swedish University of Agricultural Sciences (SLU). Thanks to SLU, to the SLU Global bioinformatics Centre (SGBC) and to SLUBI ( SLU Bioinformatics Infrastructure )","title":"Thanks and contributors"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"project_organisation/","text":"Project organization and management \u00b6 Most of the the project organization material can be found at https://software-carpentry.org and http://www.datacarpentry.org Many thanks to them for existing! Structure or architecture of a data science project \u00b6 Some good practice when you will organise your project directory on the server, on the cloud or any other machine where you will compute: Create 3 or 4 different directories within you project directory (use mkdir ): data/ for keeping the raw data results/ for all the outputs from the multiple analyses that you will perform docs/ for all the notes written about the analyses carried out (ex: history > 20180125.logs for the commands executed today) scripts/ for all the scripts that you will use to produce the results Note You should always have the raw data in (at least) one place and not modify them More about data structure and metadata \u00b6 direct link to the tutorial used fo the lesson: Shell genomics: project organisation good practice for the structure of data and metadata of a genomics project: Organisation of genomics project Some extra material: Spreadsheet ecology lesson Exercise \u00b6 This exercise combines the knowledge you have acquired during the unix , git and project organisation lessons. You have designed an experiment where you are studying the species and weight of animals caught in plots in a study area. Data was collected by a third party a deposited in figshare , a public database. Our goals are to download and exploring the data, while keeping an organised project directory that we will version control using git! Set up \u00b6 First we go to our Desktop and create a project directory cd ~/Desktop mkdir 2018_animals cd 2018_animals and initialize 2018_animals as a git repository git init As we saw during the project organization tutorial, it is good practice to separate data, results and scripts. Let us create those three directories mkdir data results scripts Downloading the data \u00b6 First we go to our data directory cd data then we download our data file and give it a more appropriate name wget https://ndownloader.figshare.com/files/2292169 mv 2292169 survey_data.csv Since we'll never modify our raw data file (or at least we do not want to! ) it is safer to remove the writing permissions chmod -w survey_data.csv Additionally since we are now unable to modify it, we do not want to track it in our git repository. We add a .gitignore and tell git to not track the data/ directory nano .gitignore Note what if my data is really big? Usually when you download data that is several gigabytes large, they will usually be compressed. You learnt about compression during the installing software lesson. Let us look at the first few lines of our file: head data/data_joined.csv Our data file is a .csv file, that is a file where fields are separated by commas , . Each row represent an animal that was caught in a plot, and each column contains information about that animal. Question How many animals do we have? wc -l data/data_joined.csv # 34787 data/data_joined.csv It seems that our dataset contains 34787 lines. Since each line is an animals, we caught a grand total of 34787 animals over the course of our study. Our first analysis script \u00b6 we saw when we did the head command that all 10 first plots captured rodents. Question Is rodent the only taxon that we have captured? In our csv file, we can see that \"taxa\" is the 12th column. We can print only that column using the cut command cut -d ',' -f 12 data/data_joined.csv | head We still pipe in in head because we do not want to print 34787 line to our screen. Additionally head makes us notice that we still have the column header printed out cut -d ',' -f 12 data/data_joined.csv | tail -n +2 | uniq -c But while uniq is supposed to count all occurrence of a word, it only count similar adjacent occurrences. Before counting, we need to sort our input: cut -d ',' -f 12 data/data_joined.csv | tail -n +2 | sort | uniq -c We see that although we caught a vast majority of rodents, we also caught reptiles, birds and rabbits! Now that we have a working one-liner, let us put it into a script nano scripts/taxa_count.sh and write # script that prints the count of species for csv files cut -d ',' -f 12 \"$1\" | tail -n +2 | sort | uniq -c Keeping track of things \u00b6 Now keep track of your script in git git add scripts/taxa_count.sh git commit -m 'added taxa_count' as well as your gitignore git add .gitignore git commit -m 'added gitignore' Saving the result \u00b6 bash scripts/taxa_count.sh data/data_joined.csv > results/taxa_count.txt cat results/taxa_count.txt git add results/taxa_count.txt git commit -m 'added results of taxa_count.sh' Improving our script \u00b6 We would also like to know the distribution of the numbers of animals caught in plots each year. The year is the 4th column in our dataset and our script, in its current state, always selects the 12th columns of a file. We can change our script to make it flexible so that the user can chose which columns they wishes to work on. nano scripts/taxa_count.sh # script that prints the count of occurrence in one column for csv files cut -d ',' -f \"$2\" \"$1\" | tail -n +2 | sort | uniq -c Now it doesn't make much sense to have it named taxa_count.sh mv scripts/taxa_count.sh scripts/column_count.sh and let us not forget to keep track of our changes in git! git add -A git commit -m 'made script more flexible about which column to cut on' Question which year did we catch the most animals? try to answer programmatically. Question save the sorted output to a file in the results directory and keep track of it in git. Investigating further \u00b6 We'd like to refine our animal count and knowing how many animals of each taxon were captured every year we can use cut on several columns like this: cut -d ',' -f 4,12 \"data/data_joined.csv\" | tail -n +2 | sort | uniq -c Now that we are ahhpy with our one-liner, let us save it in a script: nano scripts/taxa_per_year.sh then save the output to results/taxa_per_year.txt bash scripts/taxa_per_year.sh > results/taxa_per_year.txt Question Which year was the first reptile captured? The next step would be to refine our analysis by year. We will save one individual output for each year count The seq command \u00b6 To perform what we want to do, we need to be able to loop over the years. The seq command can help us with that. First we try seq 1 10 then seq 1997 2002 and what about the span of years we are interested in? seq 1977 2002 Great! So now does it work with a for loop? for year in $(seq 1977 2002) do echo $year done It does! Before doing our analysis on each year, we still have to figure out how to do it on one year. grep 1998 results/taxa_per_year.txt \"Grepping\" the year seems to work. Now we need to save it into a file containing the year First let's create a directory where to store our results mkdir results/years and we try to redirect our yearly count into a file grep 1998 results/taxa_per_year.txt > results/years/1998-count.txt bash cat results/years/1998-count.txt It seems to have worked. Now with the loop for year in $(seq 1977 2002) do grep $year results/taxa_per_year.txt > results/years/$year-count.txt done ls results/years Question Put your loop in a script, and commit everything with git","title":"Project organisation"},{"location":"project_organisation/#project-organization-and-management","text":"Most of the the project organization material can be found at https://software-carpentry.org and http://www.datacarpentry.org Many thanks to them for existing!","title":"Project organization and management"},{"location":"project_organisation/#structure-or-architecture-of-a-data-science-project","text":"Some good practice when you will organise your project directory on the server, on the cloud or any other machine where you will compute: Create 3 or 4 different directories within you project directory (use mkdir ): data/ for keeping the raw data results/ for all the outputs from the multiple analyses that you will perform docs/ for all the notes written about the analyses carried out (ex: history > 20180125.logs for the commands executed today) scripts/ for all the scripts that you will use to produce the results Note You should always have the raw data in (at least) one place and not modify them","title":"Structure or architecture of a data science project"},{"location":"project_organisation/#more-about-data-structure-and-metadata","text":"direct link to the tutorial used fo the lesson: Shell genomics: project organisation good practice for the structure of data and metadata of a genomics project: Organisation of genomics project Some extra material: Spreadsheet ecology lesson","title":"More about data structure and metadata"},{"location":"project_organisation/#exercise","text":"This exercise combines the knowledge you have acquired during the unix , git and project organisation lessons. You have designed an experiment where you are studying the species and weight of animals caught in plots in a study area. Data was collected by a third party a deposited in figshare , a public database. Our goals are to download and exploring the data, while keeping an organised project directory that we will version control using git!","title":"Exercise"},{"location":"project_organisation/#set-up","text":"First we go to our Desktop and create a project directory cd ~/Desktop mkdir 2018_animals cd 2018_animals and initialize 2018_animals as a git repository git init As we saw during the project organization tutorial, it is good practice to separate data, results and scripts. Let us create those three directories mkdir data results scripts","title":"Set up"},{"location":"project_organisation/#downloading-the-data","text":"First we go to our data directory cd data then we download our data file and give it a more appropriate name wget https://ndownloader.figshare.com/files/2292169 mv 2292169 survey_data.csv Since we'll never modify our raw data file (or at least we do not want to! ) it is safer to remove the writing permissions chmod -w survey_data.csv Additionally since we are now unable to modify it, we do not want to track it in our git repository. We add a .gitignore and tell git to not track the data/ directory nano .gitignore Note what if my data is really big? Usually when you download data that is several gigabytes large, they will usually be compressed. You learnt about compression during the installing software lesson. Let us look at the first few lines of our file: head data/data_joined.csv Our data file is a .csv file, that is a file where fields are separated by commas , . Each row represent an animal that was caught in a plot, and each column contains information about that animal. Question How many animals do we have? wc -l data/data_joined.csv # 34787 data/data_joined.csv It seems that our dataset contains 34787 lines. Since each line is an animals, we caught a grand total of 34787 animals over the course of our study.","title":"Downloading the data"},{"location":"project_organisation/#our-first-analysis-script","text":"we saw when we did the head command that all 10 first plots captured rodents. Question Is rodent the only taxon that we have captured? In our csv file, we can see that \"taxa\" is the 12th column. We can print only that column using the cut command cut -d ',' -f 12 data/data_joined.csv | head We still pipe in in head because we do not want to print 34787 line to our screen. Additionally head makes us notice that we still have the column header printed out cut -d ',' -f 12 data/data_joined.csv | tail -n +2 | uniq -c But while uniq is supposed to count all occurrence of a word, it only count similar adjacent occurrences. Before counting, we need to sort our input: cut -d ',' -f 12 data/data_joined.csv | tail -n +2 | sort | uniq -c We see that although we caught a vast majority of rodents, we also caught reptiles, birds and rabbits! Now that we have a working one-liner, let us put it into a script nano scripts/taxa_count.sh and write # script that prints the count of species for csv files cut -d ',' -f 12 \"$1\" | tail -n +2 | sort | uniq -c","title":"Our first analysis script"},{"location":"project_organisation/#keeping-track-of-things","text":"Now keep track of your script in git git add scripts/taxa_count.sh git commit -m 'added taxa_count' as well as your gitignore git add .gitignore git commit -m 'added gitignore'","title":"Keeping track of things"},{"location":"project_organisation/#saving-the-result","text":"bash scripts/taxa_count.sh data/data_joined.csv > results/taxa_count.txt cat results/taxa_count.txt git add results/taxa_count.txt git commit -m 'added results of taxa_count.sh'","title":"Saving the result"},{"location":"project_organisation/#improving-our-script","text":"We would also like to know the distribution of the numbers of animals caught in plots each year. The year is the 4th column in our dataset and our script, in its current state, always selects the 12th columns of a file. We can change our script to make it flexible so that the user can chose which columns they wishes to work on. nano scripts/taxa_count.sh # script that prints the count of occurrence in one column for csv files cut -d ',' -f \"$2\" \"$1\" | tail -n +2 | sort | uniq -c Now it doesn't make much sense to have it named taxa_count.sh mv scripts/taxa_count.sh scripts/column_count.sh and let us not forget to keep track of our changes in git! git add -A git commit -m 'made script more flexible about which column to cut on' Question which year did we catch the most animals? try to answer programmatically. Question save the sorted output to a file in the results directory and keep track of it in git.","title":"Improving our script"},{"location":"project_organisation/#investigating-further","text":"We'd like to refine our animal count and knowing how many animals of each taxon were captured every year we can use cut on several columns like this: cut -d ',' -f 4,12 \"data/data_joined.csv\" | tail -n +2 | sort | uniq -c Now that we are ahhpy with our one-liner, let us save it in a script: nano scripts/taxa_per_year.sh then save the output to results/taxa_per_year.txt bash scripts/taxa_per_year.sh > results/taxa_per_year.txt Question Which year was the first reptile captured? The next step would be to refine our analysis by year. We will save one individual output for each year count","title":"Investigating further"},{"location":"project_organisation/#the-seq-command","text":"To perform what we want to do, we need to be able to loop over the years. The seq command can help us with that. First we try seq 1 10 then seq 1997 2002 and what about the span of years we are interested in? seq 1977 2002 Great! So now does it work with a for loop? for year in $(seq 1977 2002) do echo $year done It does! Before doing our analysis on each year, we still have to figure out how to do it on one year. grep 1998 results/taxa_per_year.txt \"Grepping\" the year seems to work. Now we need to save it into a file containing the year First let's create a directory where to store our results mkdir results/years and we try to redirect our yearly count into a file grep 1998 results/taxa_per_year.txt > results/years/1998-count.txt bash cat results/years/1998-count.txt It seems to have worked. Now with the loop for year in $(seq 1977 2002) do grep $year results/taxa_per_year.txt > results/years/$year-count.txt done ls results/years Question Put your loop in a script, and commit everything with git","title":"The seq command"},{"location":"qc/","text":"Quality Control and Trimming \u00b6 Lecture \u00b6 Practical \u00b6 In this practical you will learn to import, view and check the quality of raw high thoughput sequencing sequencing data. The first dataset you will be working with is from an Illumina MiSeq dataset. The sequenced organism is an enterohaemorrhagic E. coli (EHEC) of the serotype O157, a potentially fatal gastrointestinal pathogen. The sequenced bacterium was part of an outbreak investigation in the St. Louis area, USA in 2011. The sequencing was done as paired-end 2x150bp. Downloading the data \u00b6 The raw data were deposited at the European Nucleotide Archive, under the accession number SRR957824. You could go to the ENA website and search for the run with the accession SRR957824. However these files contain about 3 million reads and are therefore quite big. We are only going to use a subset of the original dataset for this tutorial. First create a data/ directory in your home folder mkdir ~/data now let's download the subset cd ~/data curl -O -J -L https://osf.io/shqpv/download curl -O -J -L https://osf.io/9m3ch/download Let\u2019s make sure we downloaded all of our data using md5sum. md5sum SRR957824_500K_R1.fastq.gz SRR957824_500K_R2.fastq.gz you should see this 1e8cf249e3217a5a0bcc0d8a654585fb SRR957824_500K_R1.fastq.gz 70c726a31f05f856fe942d727613adb7 SRR957824_500K_R2.fastq.gz and now look at the file names and their size ls -l total 97M -rw-r--r-- 1 hadrien 48M Nov 19 18:44 SRR957824_500K_R1.fastq.gz -rw-r--r-- 1 hadrien 50M Nov 19 18:53 SRR957824_500K_R2.fastq.gz There are 500 000 paired-end reads taken randomly from the original data One last thing before we get to the quality control: those files are writeable. By default, UNIX makes things writeable by the file owner. This poses an issue with creating typos or errors in raw data. We fix that before going further chmod u-w * Working Directory \u00b6 First we make a work directory: a directory where we can play around with a copy of the data without messing with the original mkdir ~/work cd ~/work Now we make a link of the data in our working directory ln -s ~/data/* . The files that we've downloaded are FASTQ files. Take a look at one of them with zless SRR957824_500K_R1.fastq.gz Tip Use the spacebar to scroll down, and type \u2018q\u2019 to exit \u2018less\u2019 You can read more on the FASTQ format in the File Formats lesson. Question Where does the filename come from? Question Why are there 1 and 2 in the file names? FastQC \u00b6 To check the quality of the sequence data we will use a tool called FastQC. FastQC has a graphical interface and can be downloaded and run on a Windows or Linux computer without installation. It is available here . However, FastQC is also available as a command line utility on the training server you are using. To run FastQC on our two files fastqc SRR957824_500K_R1.fastq.gz SRR957824_500K_R2.fastq.gz and look what FastQC has produced ls *fastqc* For each file, FastQC has produced both a .zip archive containing all the plots, and a html report. Download and open the html files with your favourite web browser. Alternatively you can look a these copies of them: SRR957824_500K_R1_fastqc.html SRR957824_500K_R2_fastqc.html Question What should you pay attention to in the FastQC report? Question Which file is of better quality? Pay special attention to the per base sequence quality and sequence length distribution. Explanations for the various quality modules can be found here . Also, have a look at examples of a good and a bad illumina read set for comparison. You will note that the reads in your uploaded dataset have fairly poor quality (<20) towards the end. There are also outlier reads that have very poor quality for most of the second half of the reads. Scythe \u00b6 Now we'll do some trimming! Scythe uses a Naive Bayesian approach to classify contaminant substrings in sequence reads. It considers quality information, which can make it robust in picking out 3'-end adapters, which often include poor quality bases. The first thing we need is the adapters to trim off curl -O -J -L https://osf.io/v24pt/download Now we run scythe on both our read files scythe -a adapters.fasta SRR957824_500K_R1.fastq.gz -o SRR957824_adapt_R1.fastq scythe -a adapters.fasta SRR957824_500K_R2.fastq.gz -o SRR957824_adapt_R2.fastq Question What adapters do you use? Sickle \u00b6 Most modern sequencing technologies produce reads that have deteriorating quality towards the 3'-end and some towards the 5'-end as well. Incorrectly called bases in both regions negatively impact assembles, mapping, and downstream bioinformatics analyses. We will trim each read individually down to the good quality part to keep the bad part from interfering with downstream applications. To do so, we will use sickle. Sickle is a tool that uses sliding windows along with quality and length thresholds to determine when quality is sufficiently low to trim the 3'-end of reads and also determines when the quality is sufficiently high enough to trim the 5'-end of reads. It will also discard reads based upon a length threshold. To run sickle sickle pe -f SRR957824_adapt_R1.fastq -r SRR957824_adapt_R2.fastq \\ -t sanger -o SRR957824_trimmed_R1.fastq -p SRR957824_trimmed_R2.fastq \\ -s /dev/null -q 25 which should output something like PE forward file: SRR957824_trimmed_R1.fastq PE reverse file: SRR957824_trimmed_R2.fastq Total input FastQ records: 1000000 (500000 pairs) FastQ paired records kept: 834570 (417285 pairs) FastQ single records kept: 13263 (from PE1: 11094, from PE2: 2169) FastQ paired records discarded: 138904 (69452 pairs) FastQ single records discarded: 13263 (from PE1: 2169, from PE2: 11094) FastQC again \u00b6 Run fastqc again on the filtered reads fastqc SRR957824_trimmed_R1.fastq SRR957824_trimmed_R2.fastq and look at the reports SRR957824_trimmed_R1_fastqc.html SRR957824_trimmed_R2_fastqc.html MultiQC \u00b6 MultiQC is a tool that aggreagtes results from several popular QC bioinformatics software into one html report. Let's run MultiQC in our current directory multiqc . You can download the report or view it by clicking on the link below multiqc_report.html Question What did the trimming do to the per-base sequence quality, the per sequence quality scores and the sequence length distribution?","title":"Quality Control and Trimming"},{"location":"qc/#quality-control-and-trimming","text":"","title":"Quality Control and Trimming"},{"location":"qc/#lecture","text":"","title":"Lecture"},{"location":"qc/#practical","text":"In this practical you will learn to import, view and check the quality of raw high thoughput sequencing sequencing data. The first dataset you will be working with is from an Illumina MiSeq dataset. The sequenced organism is an enterohaemorrhagic E. coli (EHEC) of the serotype O157, a potentially fatal gastrointestinal pathogen. The sequenced bacterium was part of an outbreak investigation in the St. Louis area, USA in 2011. The sequencing was done as paired-end 2x150bp.","title":"Practical"},{"location":"qc/#downloading-the-data","text":"The raw data were deposited at the European Nucleotide Archive, under the accession number SRR957824. You could go to the ENA website and search for the run with the accession SRR957824. However these files contain about 3 million reads and are therefore quite big. We are only going to use a subset of the original dataset for this tutorial. First create a data/ directory in your home folder mkdir ~/data now let's download the subset cd ~/data curl -O -J -L https://osf.io/shqpv/download curl -O -J -L https://osf.io/9m3ch/download Let\u2019s make sure we downloaded all of our data using md5sum. md5sum SRR957824_500K_R1.fastq.gz SRR957824_500K_R2.fastq.gz you should see this 1e8cf249e3217a5a0bcc0d8a654585fb SRR957824_500K_R1.fastq.gz 70c726a31f05f856fe942d727613adb7 SRR957824_500K_R2.fastq.gz and now look at the file names and their size ls -l total 97M -rw-r--r-- 1 hadrien 48M Nov 19 18:44 SRR957824_500K_R1.fastq.gz -rw-r--r-- 1 hadrien 50M Nov 19 18:53 SRR957824_500K_R2.fastq.gz There are 500 000 paired-end reads taken randomly from the original data One last thing before we get to the quality control: those files are writeable. By default, UNIX makes things writeable by the file owner. This poses an issue with creating typos or errors in raw data. We fix that before going further chmod u-w *","title":"Downloading the data"},{"location":"qc/#working-directory","text":"First we make a work directory: a directory where we can play around with a copy of the data without messing with the original mkdir ~/work cd ~/work Now we make a link of the data in our working directory ln -s ~/data/* . The files that we've downloaded are FASTQ files. Take a look at one of them with zless SRR957824_500K_R1.fastq.gz Tip Use the spacebar to scroll down, and type \u2018q\u2019 to exit \u2018less\u2019 You can read more on the FASTQ format in the File Formats lesson. Question Where does the filename come from? Question Why are there 1 and 2 in the file names?","title":"Working Directory"},{"location":"qc/#fastqc","text":"To check the quality of the sequence data we will use a tool called FastQC. FastQC has a graphical interface and can be downloaded and run on a Windows or Linux computer without installation. It is available here . However, FastQC is also available as a command line utility on the training server you are using. To run FastQC on our two files fastqc SRR957824_500K_R1.fastq.gz SRR957824_500K_R2.fastq.gz and look what FastQC has produced ls *fastqc* For each file, FastQC has produced both a .zip archive containing all the plots, and a html report. Download and open the html files with your favourite web browser. Alternatively you can look a these copies of them: SRR957824_500K_R1_fastqc.html SRR957824_500K_R2_fastqc.html Question What should you pay attention to in the FastQC report? Question Which file is of better quality? Pay special attention to the per base sequence quality and sequence length distribution. Explanations for the various quality modules can be found here . Also, have a look at examples of a good and a bad illumina read set for comparison. You will note that the reads in your uploaded dataset have fairly poor quality (<20) towards the end. There are also outlier reads that have very poor quality for most of the second half of the reads.","title":"FastQC"},{"location":"qc/#scythe","text":"Now we'll do some trimming! Scythe uses a Naive Bayesian approach to classify contaminant substrings in sequence reads. It considers quality information, which can make it robust in picking out 3'-end adapters, which often include poor quality bases. The first thing we need is the adapters to trim off curl -O -J -L https://osf.io/v24pt/download Now we run scythe on both our read files scythe -a adapters.fasta SRR957824_500K_R1.fastq.gz -o SRR957824_adapt_R1.fastq scythe -a adapters.fasta SRR957824_500K_R2.fastq.gz -o SRR957824_adapt_R2.fastq Question What adapters do you use?","title":"Scythe"},{"location":"qc/#sickle","text":"Most modern sequencing technologies produce reads that have deteriorating quality towards the 3'-end and some towards the 5'-end as well. Incorrectly called bases in both regions negatively impact assembles, mapping, and downstream bioinformatics analyses. We will trim each read individually down to the good quality part to keep the bad part from interfering with downstream applications. To do so, we will use sickle. Sickle is a tool that uses sliding windows along with quality and length thresholds to determine when quality is sufficiently low to trim the 3'-end of reads and also determines when the quality is sufficiently high enough to trim the 5'-end of reads. It will also discard reads based upon a length threshold. To run sickle sickle pe -f SRR957824_adapt_R1.fastq -r SRR957824_adapt_R2.fastq \\ -t sanger -o SRR957824_trimmed_R1.fastq -p SRR957824_trimmed_R2.fastq \\ -s /dev/null -q 25 which should output something like PE forward file: SRR957824_trimmed_R1.fastq PE reverse file: SRR957824_trimmed_R2.fastq Total input FastQ records: 1000000 (500000 pairs) FastQ paired records kept: 834570 (417285 pairs) FastQ single records kept: 13263 (from PE1: 11094, from PE2: 2169) FastQ paired records discarded: 138904 (69452 pairs) FastQ single records discarded: 13263 (from PE1: 2169, from PE2: 11094)","title":"Sickle"},{"location":"qc/#fastqc-again","text":"Run fastqc again on the filtered reads fastqc SRR957824_trimmed_R1.fastq SRR957824_trimmed_R2.fastq and look at the reports SRR957824_trimmed_R1_fastqc.html SRR957824_trimmed_R2_fastqc.html","title":"FastQC again"},{"location":"qc/#multiqc","text":"MultiQC is a tool that aggreagtes results from several popular QC bioinformatics software into one html report. Let's run MultiQC in our current directory multiqc . You can download the report or view it by clicking on the link below multiqc_report.html Question What did the trimming do to the per-base sequence quality, the per sequence quality scores and the sequence length distribution?","title":"MultiQC"},{"location":"unix/","text":"Introduction to Unix \u00b6 Most of the introduction to Unix material can be found at https://software-carpentry.org Many thanks to them for existing! Useful resources \u00b6 Below you will find links to various useful resources for learning or using the UNIX shell. Link to the course material from software carpentry reference of concepts and commands seen during the lesson shell commands explained - a website that shows the help text of any command awesome bash - an awesome list of resources about the bash shell tldp - the linux documentation project (the books can be hard to digest but are very thorough)","title":"The Unix system"},{"location":"unix/#introduction-to-unix","text":"Most of the introduction to Unix material can be found at https://software-carpentry.org Many thanks to them for existing!","title":"Introduction to Unix"},{"location":"unix/#useful-resources","text":"Below you will find links to various useful resources for learning or using the UNIX shell. Link to the course material from software carpentry reference of concepts and commands seen during the lesson shell commands explained - a website that shows the help text of any command awesome bash - an awesome list of resources about the bash shell tldp - the linux documentation project (the books can be hard to digest but are very thorough)","title":"Useful resources"}]}